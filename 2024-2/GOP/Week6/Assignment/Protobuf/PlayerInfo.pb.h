// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PlayerInfo.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_PlayerInfo_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_PlayerInfo_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_PlayerInfo_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_PlayerInfo_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_PlayerInfo_2eproto;
namespace Week6Assignment {
class AllPlayersInfoRequest;
struct AllPlayersInfoRequestDefaultTypeInternal;
extern AllPlayersInfoRequestDefaultTypeInternal _AllPlayersInfoRequest_default_instance_;
class AllPlayersInfoResponse;
struct AllPlayersInfoResponseDefaultTypeInternal;
extern AllPlayersInfoResponseDefaultTypeInternal _AllPlayersInfoResponse_default_instance_;
class ErrorResponse;
struct ErrorResponseDefaultTypeInternal;
extern ErrorResponseDefaultTypeInternal _ErrorResponse_default_instance_;
class Inventory;
struct InventoryDefaultTypeInternal;
extern InventoryDefaultTypeInternal _Inventory_default_instance_;
class Item;
struct ItemDefaultTypeInternal;
extern ItemDefaultTypeInternal _Item_default_instance_;
class PlayerInfo;
struct PlayerInfoDefaultTypeInternal;
extern PlayerInfoDefaultTypeInternal _PlayerInfo_default_instance_;
class PlayerInfoRequest;
struct PlayerInfoRequestDefaultTypeInternal;
extern PlayerInfoRequestDefaultTypeInternal _PlayerInfoRequest_default_instance_;
class PlayerInfoResponse;
struct PlayerInfoResponseDefaultTypeInternal;
extern PlayerInfoResponseDefaultTypeInternal _PlayerInfoResponse_default_instance_;
class PlayerInventoryRequest;
struct PlayerInventoryRequestDefaultTypeInternal;
extern PlayerInventoryRequestDefaultTypeInternal _PlayerInventoryRequest_default_instance_;
class PlayerInventoryResponse;
struct PlayerInventoryResponseDefaultTypeInternal;
extern PlayerInventoryResponseDefaultTypeInternal _PlayerInventoryResponse_default_instance_;
class WrappedRequestMessage;
struct WrappedRequestMessageDefaultTypeInternal;
extern WrappedRequestMessageDefaultTypeInternal _WrappedRequestMessage_default_instance_;
class WrappedResponseMessage;
struct WrappedResponseMessageDefaultTypeInternal;
extern WrappedResponseMessageDefaultTypeInternal _WrappedResponseMessage_default_instance_;
}  // namespace Week6Assignment
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace Week6Assignment {

// ===================================================================


// -------------------------------------------------------------------

class PlayerInventoryRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Week6Assignment.PlayerInventoryRequest) */ {
 public:
  inline PlayerInventoryRequest() : PlayerInventoryRequest(nullptr) {}
  ~PlayerInventoryRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerInventoryRequest(::google::protobuf::internal::ConstantInitialized);

  inline PlayerInventoryRequest(const PlayerInventoryRequest& from)
      : PlayerInventoryRequest(nullptr, from) {}
  PlayerInventoryRequest(PlayerInventoryRequest&& from) noexcept
    : PlayerInventoryRequest() {
    *this = ::std::move(from);
  }

  inline PlayerInventoryRequest& operator=(const PlayerInventoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInventoryRequest& operator=(PlayerInventoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerInventoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerInventoryRequest* internal_default_instance() {
    return reinterpret_cast<const PlayerInventoryRequest*>(
               &_PlayerInventoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PlayerInventoryRequest& a, PlayerInventoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerInventoryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInventoryRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerInventoryRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerInventoryRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerInventoryRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PlayerInventoryRequest& from) {
    PlayerInventoryRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerInventoryRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Week6Assignment.PlayerInventoryRequest";
  }
  protected:
  explicit PlayerInventoryRequest(::google::protobuf::Arena* arena);
  PlayerInventoryRequest(::google::protobuf::Arena* arena, const PlayerInventoryRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint32 id = 1;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Week6Assignment.PlayerInventoryRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PlayerInfo_2eproto;
};// -------------------------------------------------------------------

class PlayerInfoRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Week6Assignment.PlayerInfoRequest) */ {
 public:
  inline PlayerInfoRequest() : PlayerInfoRequest(nullptr) {}
  ~PlayerInfoRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerInfoRequest(::google::protobuf::internal::ConstantInitialized);

  inline PlayerInfoRequest(const PlayerInfoRequest& from)
      : PlayerInfoRequest(nullptr, from) {}
  PlayerInfoRequest(PlayerInfoRequest&& from) noexcept
    : PlayerInfoRequest() {
    *this = ::std::move(from);
  }

  inline PlayerInfoRequest& operator=(const PlayerInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInfoRequest& operator=(PlayerInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerInfoRequest* internal_default_instance() {
    return reinterpret_cast<const PlayerInfoRequest*>(
               &_PlayerInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PlayerInfoRequest& a, PlayerInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInfoRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerInfoRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerInfoRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerInfoRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PlayerInfoRequest& from) {
    PlayerInfoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerInfoRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Week6Assignment.PlayerInfoRequest";
  }
  protected:
  explicit PlayerInfoRequest(::google::protobuf::Arena* arena);
  PlayerInfoRequest(::google::protobuf::Arena* arena, const PlayerInfoRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint32 id = 1;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Week6Assignment.PlayerInfoRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PlayerInfo_2eproto;
};// -------------------------------------------------------------------

class Item final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Week6Assignment.Item) */ {
 public:
  inline Item() : Item(nullptr) {}
  ~Item() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Item(::google::protobuf::internal::ConstantInitialized);

  inline Item(const Item& from)
      : Item(nullptr, from) {}
  Item(Item&& from) noexcept
    : Item() {
    *this = ::std::move(from);
  }

  inline Item& operator=(const Item& from) {
    CopyFrom(from);
    return *this;
  }
  inline Item& operator=(Item&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Item& default_instance() {
    return *internal_default_instance();
  }
  static inline const Item* internal_default_instance() {
    return reinterpret_cast<const Item*>(
               &_Item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Item& a, Item& b) {
    a.Swap(&b);
  }
  inline void Swap(Item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Item* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Item* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Item>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Item& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Item& from) {
    Item::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Item* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Week6Assignment.Item";
  }
  protected:
  explicit Item(::google::protobuf::Arena* arena);
  Item(::google::protobuf::Arena* arena, const Item& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kIdFieldNumber = 1,
    kQuantityFieldNumber = 3,
  };
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // uint32 id = 1;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // uint32 quantity = 3;
  void clear_quantity() ;
  ::uint32_t quantity() const;
  void set_quantity(::uint32_t value);

  private:
  ::uint32_t _internal_quantity() const;
  void _internal_set_quantity(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Week6Assignment.Item)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      33, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::uint32_t id_;
    ::uint32_t quantity_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PlayerInfo_2eproto;
};// -------------------------------------------------------------------

class ErrorResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Week6Assignment.ErrorResponse) */ {
 public:
  inline ErrorResponse() : ErrorResponse(nullptr) {}
  ~ErrorResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ErrorResponse(::google::protobuf::internal::ConstantInitialized);

  inline ErrorResponse(const ErrorResponse& from)
      : ErrorResponse(nullptr, from) {}
  ErrorResponse(ErrorResponse&& from) noexcept
    : ErrorResponse() {
    *this = ::std::move(from);
  }

  inline ErrorResponse& operator=(const ErrorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorResponse& operator=(ErrorResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ErrorResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrorResponse* internal_default_instance() {
    return reinterpret_cast<const ErrorResponse*>(
               &_ErrorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ErrorResponse& a, ErrorResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ErrorResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ErrorResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ErrorResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ErrorResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ErrorResponse& from) {
    ErrorResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ErrorResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Week6Assignment.ErrorResponse";
  }
  protected:
  explicit ErrorResponse(::google::protobuf::Arena* arena);
  ErrorResponse(::google::protobuf::Arena* arena, const ErrorResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // @@protoc_insertion_point(class_scope:Week6Assignment.ErrorResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      45, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PlayerInfo_2eproto;
};// -------------------------------------------------------------------

class AllPlayersInfoRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Week6Assignment.AllPlayersInfoRequest) */ {
 public:
  inline AllPlayersInfoRequest() : AllPlayersInfoRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AllPlayersInfoRequest(::google::protobuf::internal::ConstantInitialized);

  inline AllPlayersInfoRequest(const AllPlayersInfoRequest& from)
      : AllPlayersInfoRequest(nullptr, from) {}
  AllPlayersInfoRequest(AllPlayersInfoRequest&& from) noexcept
    : AllPlayersInfoRequest() {
    *this = ::std::move(from);
  }

  inline AllPlayersInfoRequest& operator=(const AllPlayersInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllPlayersInfoRequest& operator=(AllPlayersInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllPlayersInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllPlayersInfoRequest* internal_default_instance() {
    return reinterpret_cast<const AllPlayersInfoRequest*>(
               &_AllPlayersInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AllPlayersInfoRequest& a, AllPlayersInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AllPlayersInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllPlayersInfoRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllPlayersInfoRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllPlayersInfoRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AllPlayersInfoRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AllPlayersInfoRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Week6Assignment.AllPlayersInfoRequest";
  }
  protected:
  explicit AllPlayersInfoRequest(::google::protobuf::Arena* arena);
  AllPlayersInfoRequest(::google::protobuf::Arena* arena, const AllPlayersInfoRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Week6Assignment.AllPlayersInfoRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_PlayerInfo_2eproto;
};// -------------------------------------------------------------------

class WrappedRequestMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Week6Assignment.WrappedRequestMessage) */ {
 public:
  inline WrappedRequestMessage() : WrappedRequestMessage(nullptr) {}
  ~WrappedRequestMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WrappedRequestMessage(::google::protobuf::internal::ConstantInitialized);

  inline WrappedRequestMessage(const WrappedRequestMessage& from)
      : WrappedRequestMessage(nullptr, from) {}
  WrappedRequestMessage(WrappedRequestMessage&& from) noexcept
    : WrappedRequestMessage() {
    *this = ::std::move(from);
  }

  inline WrappedRequestMessage& operator=(const WrappedRequestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline WrappedRequestMessage& operator=(WrappedRequestMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WrappedRequestMessage& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kPlayerInfoRequest = 1,
    kAllPlayersInfoRequest = 2,
    kPlayerInventoryRequest = 3,
    MESSAGE_NOT_SET = 0,
  };

  static inline const WrappedRequestMessage* internal_default_instance() {
    return reinterpret_cast<const WrappedRequestMessage*>(
               &_WrappedRequestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(WrappedRequestMessage& a, WrappedRequestMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(WrappedRequestMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WrappedRequestMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WrappedRequestMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WrappedRequestMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WrappedRequestMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WrappedRequestMessage& from) {
    WrappedRequestMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WrappedRequestMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Week6Assignment.WrappedRequestMessage";
  }
  protected:
  explicit WrappedRequestMessage(::google::protobuf::Arena* arena);
  WrappedRequestMessage(::google::protobuf::Arena* arena, const WrappedRequestMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerInfoRequestFieldNumber = 1,
    kAllPlayersInfoRequestFieldNumber = 2,
    kPlayerInventoryRequestFieldNumber = 3,
  };
  // .Week6Assignment.PlayerInfoRequest playerInfoRequest = 1;
  bool has_playerinforequest() const;
  private:
  bool _internal_has_playerinforequest() const;

  public:
  void clear_playerinforequest() ;
  const ::Week6Assignment::PlayerInfoRequest& playerinforequest() const;
  PROTOBUF_NODISCARD ::Week6Assignment::PlayerInfoRequest* release_playerinforequest();
  ::Week6Assignment::PlayerInfoRequest* mutable_playerinforequest();
  void set_allocated_playerinforequest(::Week6Assignment::PlayerInfoRequest* value);
  void unsafe_arena_set_allocated_playerinforequest(::Week6Assignment::PlayerInfoRequest* value);
  ::Week6Assignment::PlayerInfoRequest* unsafe_arena_release_playerinforequest();

  private:
  const ::Week6Assignment::PlayerInfoRequest& _internal_playerinforequest() const;
  ::Week6Assignment::PlayerInfoRequest* _internal_mutable_playerinforequest();

  public:
  // .Week6Assignment.AllPlayersInfoRequest allPlayersInfoRequest = 2;
  bool has_allplayersinforequest() const;
  private:
  bool _internal_has_allplayersinforequest() const;

  public:
  void clear_allplayersinforequest() ;
  const ::Week6Assignment::AllPlayersInfoRequest& allplayersinforequest() const;
  PROTOBUF_NODISCARD ::Week6Assignment::AllPlayersInfoRequest* release_allplayersinforequest();
  ::Week6Assignment::AllPlayersInfoRequest* mutable_allplayersinforequest();
  void set_allocated_allplayersinforequest(::Week6Assignment::AllPlayersInfoRequest* value);
  void unsafe_arena_set_allocated_allplayersinforequest(::Week6Assignment::AllPlayersInfoRequest* value);
  ::Week6Assignment::AllPlayersInfoRequest* unsafe_arena_release_allplayersinforequest();

  private:
  const ::Week6Assignment::AllPlayersInfoRequest& _internal_allplayersinforequest() const;
  ::Week6Assignment::AllPlayersInfoRequest* _internal_mutable_allplayersinforequest();

  public:
  // .Week6Assignment.PlayerInventoryRequest playerInventoryRequest = 3;
  bool has_playerinventoryrequest() const;
  private:
  bool _internal_has_playerinventoryrequest() const;

  public:
  void clear_playerinventoryrequest() ;
  const ::Week6Assignment::PlayerInventoryRequest& playerinventoryrequest() const;
  PROTOBUF_NODISCARD ::Week6Assignment::PlayerInventoryRequest* release_playerinventoryrequest();
  ::Week6Assignment::PlayerInventoryRequest* mutable_playerinventoryrequest();
  void set_allocated_playerinventoryrequest(::Week6Assignment::PlayerInventoryRequest* value);
  void unsafe_arena_set_allocated_playerinventoryrequest(::Week6Assignment::PlayerInventoryRequest* value);
  ::Week6Assignment::PlayerInventoryRequest* unsafe_arena_release_playerinventoryrequest();

  private:
  const ::Week6Assignment::PlayerInventoryRequest& _internal_playerinventoryrequest() const;
  ::Week6Assignment::PlayerInventoryRequest* _internal_mutable_playerinventoryrequest();

  public:
  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:Week6Assignment.WrappedRequestMessage)
 private:
  class _Internal;
  void set_has_playerinforequest();
  void set_has_allplayersinforequest();
  void set_has_playerinventoryrequest();

  inline bool has_message() const;
  inline void clear_has_message();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::Week6Assignment::PlayerInfoRequest* playerinforequest_;
      ::Week6Assignment::AllPlayersInfoRequest* allplayersinforequest_;
      ::Week6Assignment::PlayerInventoryRequest* playerinventoryrequest_;
    } message_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PlayerInfo_2eproto;
};// -------------------------------------------------------------------

class Inventory final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Week6Assignment.Inventory) */ {
 public:
  inline Inventory() : Inventory(nullptr) {}
  ~Inventory() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Inventory(::google::protobuf::internal::ConstantInitialized);

  inline Inventory(const Inventory& from)
      : Inventory(nullptr, from) {}
  Inventory(Inventory&& from) noexcept
    : Inventory() {
    *this = ::std::move(from);
  }

  inline Inventory& operator=(const Inventory& from) {
    CopyFrom(from);
    return *this;
  }
  inline Inventory& operator=(Inventory&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Inventory& default_instance() {
    return *internal_default_instance();
  }
  static inline const Inventory* internal_default_instance() {
    return reinterpret_cast<const Inventory*>(
               &_Inventory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Inventory& a, Inventory& b) {
    a.Swap(&b);
  }
  inline void Swap(Inventory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Inventory* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Inventory* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Inventory>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Inventory& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Inventory& from) {
    Inventory::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Inventory* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Week6Assignment.Inventory";
  }
  protected:
  explicit Inventory(::google::protobuf::Arena* arena);
  Inventory(::google::protobuf::Arena* arena, const Inventory& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemFieldNumber = 1,
  };
  // repeated .Week6Assignment.Item item = 1;
  int item_size() const;
  private:
  int _internal_item_size() const;

  public:
  void clear_item() ;
  ::Week6Assignment::Item* mutable_item(int index);
  ::google::protobuf::RepeatedPtrField< ::Week6Assignment::Item >*
      mutable_item();
  private:
  const ::google::protobuf::RepeatedPtrField<::Week6Assignment::Item>& _internal_item() const;
  ::google::protobuf::RepeatedPtrField<::Week6Assignment::Item>* _internal_mutable_item();
  public:
  const ::Week6Assignment::Item& item(int index) const;
  ::Week6Assignment::Item* add_item();
  const ::google::protobuf::RepeatedPtrField< ::Week6Assignment::Item >&
      item() const;
  // @@protoc_insertion_point(class_scope:Week6Assignment.Inventory)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::Week6Assignment::Item > item_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PlayerInfo_2eproto;
};// -------------------------------------------------------------------

class PlayerInventoryResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Week6Assignment.PlayerInventoryResponse) */ {
 public:
  inline PlayerInventoryResponse() : PlayerInventoryResponse(nullptr) {}
  ~PlayerInventoryResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerInventoryResponse(::google::protobuf::internal::ConstantInitialized);

  inline PlayerInventoryResponse(const PlayerInventoryResponse& from)
      : PlayerInventoryResponse(nullptr, from) {}
  PlayerInventoryResponse(PlayerInventoryResponse&& from) noexcept
    : PlayerInventoryResponse() {
    *this = ::std::move(from);
  }

  inline PlayerInventoryResponse& operator=(const PlayerInventoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInventoryResponse& operator=(PlayerInventoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerInventoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerInventoryResponse* internal_default_instance() {
    return reinterpret_cast<const PlayerInventoryResponse*>(
               &_PlayerInventoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PlayerInventoryResponse& a, PlayerInventoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerInventoryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInventoryResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerInventoryResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerInventoryResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerInventoryResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PlayerInventoryResponse& from) {
    PlayerInventoryResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerInventoryResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Week6Assignment.PlayerInventoryResponse";
  }
  protected:
  explicit PlayerInventoryResponse(::google::protobuf::Arena* arena);
  PlayerInventoryResponse(::google::protobuf::Arena* arena, const PlayerInventoryResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInventoryFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
  };
  // .Week6Assignment.Inventory inventory = 2;
  bool has_inventory() const;
  void clear_inventory() ;
  const ::Week6Assignment::Inventory& inventory() const;
  PROTOBUF_NODISCARD ::Week6Assignment::Inventory* release_inventory();
  ::Week6Assignment::Inventory* mutable_inventory();
  void set_allocated_inventory(::Week6Assignment::Inventory* value);
  void unsafe_arena_set_allocated_inventory(::Week6Assignment::Inventory* value);
  ::Week6Assignment::Inventory* unsafe_arena_release_inventory();

  private:
  const ::Week6Assignment::Inventory& _internal_inventory() const;
  ::Week6Assignment::Inventory* _internal_mutable_inventory();

  public:
  // uint32 playerId = 1;
  void clear_playerid() ;
  ::uint32_t playerid() const;
  void set_playerid(::uint32_t value);

  private:
  ::uint32_t _internal_playerid() const;
  void _internal_set_playerid(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:Week6Assignment.PlayerInventoryResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::Week6Assignment::Inventory* inventory_;
    ::uint32_t playerid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PlayerInfo_2eproto;
};// -------------------------------------------------------------------

class PlayerInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Week6Assignment.PlayerInfo) */ {
 public:
  inline PlayerInfo() : PlayerInfo(nullptr) {}
  ~PlayerInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerInfo(::google::protobuf::internal::ConstantInitialized);

  inline PlayerInfo(const PlayerInfo& from)
      : PlayerInfo(nullptr, from) {}
  PlayerInfo(PlayerInfo&& from) noexcept
    : PlayerInfo() {
    *this = ::std::move(from);
  }

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInfo& operator=(PlayerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerInfo*>(
               &_PlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PlayerInfo& a, PlayerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PlayerInfo& from) {
    PlayerInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Week6Assignment.PlayerInfo";
  }
  protected:
  explicit PlayerInfo(::google::protobuf::Arena* arena);
  PlayerInfo(::google::protobuf::Arena* arena, const PlayerInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDisplayNameFieldNumber = 2,
    kInventoryFieldNumber = 5,
    kIdFieldNumber = 1,
    kLevelFieldNumber = 3,
    kHpFieldNumber = 4,
    kIsBannedFieldNumber = 6,
  };
  // string displayName = 2;
  void clear_displayname() ;
  const std::string& displayname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_displayname(Arg_&& arg, Args_... args);
  std::string* mutable_displayname();
  PROTOBUF_NODISCARD std::string* release_displayname();
  void set_allocated_displayname(std::string* value);

  private:
  const std::string& _internal_displayname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_displayname(
      const std::string& value);
  std::string* _internal_mutable_displayname();

  public:
  // optional .Week6Assignment.Inventory inventory = 5;
  bool has_inventory() const;
  void clear_inventory() ;
  const ::Week6Assignment::Inventory& inventory() const;
  PROTOBUF_NODISCARD ::Week6Assignment::Inventory* release_inventory();
  ::Week6Assignment::Inventory* mutable_inventory();
  void set_allocated_inventory(::Week6Assignment::Inventory* value);
  void unsafe_arena_set_allocated_inventory(::Week6Assignment::Inventory* value);
  ::Week6Assignment::Inventory* unsafe_arena_release_inventory();

  private:
  const ::Week6Assignment::Inventory& _internal_inventory() const;
  ::Week6Assignment::Inventory* _internal_mutable_inventory();

  public:
  // uint32 id = 1;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // uint32 level = 3;
  void clear_level() ;
  ::uint32_t level() const;
  void set_level(::uint32_t value);

  private:
  ::uint32_t _internal_level() const;
  void _internal_set_level(::uint32_t value);

  public:
  // uint32 hp = 4;
  void clear_hp() ;
  ::uint32_t hp() const;
  void set_hp(::uint32_t value);

  private:
  ::uint32_t _internal_hp() const;
  void _internal_set_hp(::uint32_t value);

  public:
  // optional bool isBanned = 6;
  bool has_isbanned() const;
  void clear_isbanned() ;
  bool isbanned() const;
  void set_isbanned(bool value);

  private:
  bool _internal_isbanned() const;
  void _internal_set_isbanned(bool value);

  public:
  // @@protoc_insertion_point(class_scope:Week6Assignment.PlayerInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      46, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr displayname_;
    ::Week6Assignment::Inventory* inventory_;
    ::uint32_t id_;
    ::uint32_t level_;
    ::uint32_t hp_;
    bool isbanned_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PlayerInfo_2eproto;
};// -------------------------------------------------------------------

class PlayerInfoResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Week6Assignment.PlayerInfoResponse) */ {
 public:
  inline PlayerInfoResponse() : PlayerInfoResponse(nullptr) {}
  ~PlayerInfoResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerInfoResponse(::google::protobuf::internal::ConstantInitialized);

  inline PlayerInfoResponse(const PlayerInfoResponse& from)
      : PlayerInfoResponse(nullptr, from) {}
  PlayerInfoResponse(PlayerInfoResponse&& from) noexcept
    : PlayerInfoResponse() {
    *this = ::std::move(from);
  }

  inline PlayerInfoResponse& operator=(const PlayerInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInfoResponse& operator=(PlayerInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerInfoResponse* internal_default_instance() {
    return reinterpret_cast<const PlayerInfoResponse*>(
               &_PlayerInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PlayerInfoResponse& a, PlayerInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInfoResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerInfoResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerInfoResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerInfoResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PlayerInfoResponse& from) {
    PlayerInfoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerInfoResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Week6Assignment.PlayerInfoResponse";
  }
  protected:
  explicit PlayerInfoResponse(::google::protobuf::Arena* arena);
  PlayerInfoResponse(::google::protobuf::Arena* arena, const PlayerInfoResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerFieldNumber = 1,
  };
  // .Week6Assignment.PlayerInfo player = 1;
  bool has_player() const;
  void clear_player() ;
  const ::Week6Assignment::PlayerInfo& player() const;
  PROTOBUF_NODISCARD ::Week6Assignment::PlayerInfo* release_player();
  ::Week6Assignment::PlayerInfo* mutable_player();
  void set_allocated_player(::Week6Assignment::PlayerInfo* value);
  void unsafe_arena_set_allocated_player(::Week6Assignment::PlayerInfo* value);
  ::Week6Assignment::PlayerInfo* unsafe_arena_release_player();

  private:
  const ::Week6Assignment::PlayerInfo& _internal_player() const;
  ::Week6Assignment::PlayerInfo* _internal_mutable_player();

  public:
  // @@protoc_insertion_point(class_scope:Week6Assignment.PlayerInfoResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::Week6Assignment::PlayerInfo* player_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PlayerInfo_2eproto;
};// -------------------------------------------------------------------

class AllPlayersInfoResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Week6Assignment.AllPlayersInfoResponse) */ {
 public:
  inline AllPlayersInfoResponse() : AllPlayersInfoResponse(nullptr) {}
  ~AllPlayersInfoResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AllPlayersInfoResponse(::google::protobuf::internal::ConstantInitialized);

  inline AllPlayersInfoResponse(const AllPlayersInfoResponse& from)
      : AllPlayersInfoResponse(nullptr, from) {}
  AllPlayersInfoResponse(AllPlayersInfoResponse&& from) noexcept
    : AllPlayersInfoResponse() {
    *this = ::std::move(from);
  }

  inline AllPlayersInfoResponse& operator=(const AllPlayersInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllPlayersInfoResponse& operator=(AllPlayersInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllPlayersInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllPlayersInfoResponse* internal_default_instance() {
    return reinterpret_cast<const AllPlayersInfoResponse*>(
               &_AllPlayersInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AllPlayersInfoResponse& a, AllPlayersInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AllPlayersInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllPlayersInfoResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllPlayersInfoResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllPlayersInfoResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AllPlayersInfoResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AllPlayersInfoResponse& from) {
    AllPlayersInfoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AllPlayersInfoResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Week6Assignment.AllPlayersInfoResponse";
  }
  protected:
  explicit AllPlayersInfoResponse(::google::protobuf::Arena* arena);
  AllPlayersInfoResponse(::google::protobuf::Arena* arena, const AllPlayersInfoResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
  };
  // repeated .Week6Assignment.PlayerInfo players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;

  public:
  void clear_players() ;
  ::Week6Assignment::PlayerInfo* mutable_players(int index);
  ::google::protobuf::RepeatedPtrField< ::Week6Assignment::PlayerInfo >*
      mutable_players();
  private:
  const ::google::protobuf::RepeatedPtrField<::Week6Assignment::PlayerInfo>& _internal_players() const;
  ::google::protobuf::RepeatedPtrField<::Week6Assignment::PlayerInfo>* _internal_mutable_players();
  public:
  const ::Week6Assignment::PlayerInfo& players(int index) const;
  ::Week6Assignment::PlayerInfo* add_players();
  const ::google::protobuf::RepeatedPtrField< ::Week6Assignment::PlayerInfo >&
      players() const;
  // @@protoc_insertion_point(class_scope:Week6Assignment.AllPlayersInfoResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::Week6Assignment::PlayerInfo > players_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PlayerInfo_2eproto;
};// -------------------------------------------------------------------

class WrappedResponseMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Week6Assignment.WrappedResponseMessage) */ {
 public:
  inline WrappedResponseMessage() : WrappedResponseMessage(nullptr) {}
  ~WrappedResponseMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WrappedResponseMessage(::google::protobuf::internal::ConstantInitialized);

  inline WrappedResponseMessage(const WrappedResponseMessage& from)
      : WrappedResponseMessage(nullptr, from) {}
  WrappedResponseMessage(WrappedResponseMessage&& from) noexcept
    : WrappedResponseMessage() {
    *this = ::std::move(from);
  }

  inline WrappedResponseMessage& operator=(const WrappedResponseMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline WrappedResponseMessage& operator=(WrappedResponseMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WrappedResponseMessage& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kErrorResponse = 1,
    kPlayerInfoResponse = 2,
    kAllPlayersInfoResponse = 3,
    kPlayerInventoryResponse = 4,
    MESSAGE_NOT_SET = 0,
  };

  static inline const WrappedResponseMessage* internal_default_instance() {
    return reinterpret_cast<const WrappedResponseMessage*>(
               &_WrappedResponseMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(WrappedResponseMessage& a, WrappedResponseMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(WrappedResponseMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WrappedResponseMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WrappedResponseMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WrappedResponseMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WrappedResponseMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WrappedResponseMessage& from) {
    WrappedResponseMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WrappedResponseMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Week6Assignment.WrappedResponseMessage";
  }
  protected:
  explicit WrappedResponseMessage(::google::protobuf::Arena* arena);
  WrappedResponseMessage(::google::protobuf::Arena* arena, const WrappedResponseMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorResponseFieldNumber = 1,
    kPlayerInfoResponseFieldNumber = 2,
    kAllPlayersInfoResponseFieldNumber = 3,
    kPlayerInventoryResponseFieldNumber = 4,
  };
  // .Week6Assignment.ErrorResponse errorResponse = 1;
  bool has_errorresponse() const;
  private:
  bool _internal_has_errorresponse() const;

  public:
  void clear_errorresponse() ;
  const ::Week6Assignment::ErrorResponse& errorresponse() const;
  PROTOBUF_NODISCARD ::Week6Assignment::ErrorResponse* release_errorresponse();
  ::Week6Assignment::ErrorResponse* mutable_errorresponse();
  void set_allocated_errorresponse(::Week6Assignment::ErrorResponse* value);
  void unsafe_arena_set_allocated_errorresponse(::Week6Assignment::ErrorResponse* value);
  ::Week6Assignment::ErrorResponse* unsafe_arena_release_errorresponse();

  private:
  const ::Week6Assignment::ErrorResponse& _internal_errorresponse() const;
  ::Week6Assignment::ErrorResponse* _internal_mutable_errorresponse();

  public:
  // .Week6Assignment.PlayerInfoResponse playerInfoResponse = 2;
  bool has_playerinforesponse() const;
  private:
  bool _internal_has_playerinforesponse() const;

  public:
  void clear_playerinforesponse() ;
  const ::Week6Assignment::PlayerInfoResponse& playerinforesponse() const;
  PROTOBUF_NODISCARD ::Week6Assignment::PlayerInfoResponse* release_playerinforesponse();
  ::Week6Assignment::PlayerInfoResponse* mutable_playerinforesponse();
  void set_allocated_playerinforesponse(::Week6Assignment::PlayerInfoResponse* value);
  void unsafe_arena_set_allocated_playerinforesponse(::Week6Assignment::PlayerInfoResponse* value);
  ::Week6Assignment::PlayerInfoResponse* unsafe_arena_release_playerinforesponse();

  private:
  const ::Week6Assignment::PlayerInfoResponse& _internal_playerinforesponse() const;
  ::Week6Assignment::PlayerInfoResponse* _internal_mutable_playerinforesponse();

  public:
  // .Week6Assignment.AllPlayersInfoResponse allPlayersInfoResponse = 3;
  bool has_allplayersinforesponse() const;
  private:
  bool _internal_has_allplayersinforesponse() const;

  public:
  void clear_allplayersinforesponse() ;
  const ::Week6Assignment::AllPlayersInfoResponse& allplayersinforesponse() const;
  PROTOBUF_NODISCARD ::Week6Assignment::AllPlayersInfoResponse* release_allplayersinforesponse();
  ::Week6Assignment::AllPlayersInfoResponse* mutable_allplayersinforesponse();
  void set_allocated_allplayersinforesponse(::Week6Assignment::AllPlayersInfoResponse* value);
  void unsafe_arena_set_allocated_allplayersinforesponse(::Week6Assignment::AllPlayersInfoResponse* value);
  ::Week6Assignment::AllPlayersInfoResponse* unsafe_arena_release_allplayersinforesponse();

  private:
  const ::Week6Assignment::AllPlayersInfoResponse& _internal_allplayersinforesponse() const;
  ::Week6Assignment::AllPlayersInfoResponse* _internal_mutable_allplayersinforesponse();

  public:
  // .Week6Assignment.PlayerInventoryResponse playerInventoryResponse = 4;
  bool has_playerinventoryresponse() const;
  private:
  bool _internal_has_playerinventoryresponse() const;

  public:
  void clear_playerinventoryresponse() ;
  const ::Week6Assignment::PlayerInventoryResponse& playerinventoryresponse() const;
  PROTOBUF_NODISCARD ::Week6Assignment::PlayerInventoryResponse* release_playerinventoryresponse();
  ::Week6Assignment::PlayerInventoryResponse* mutable_playerinventoryresponse();
  void set_allocated_playerinventoryresponse(::Week6Assignment::PlayerInventoryResponse* value);
  void unsafe_arena_set_allocated_playerinventoryresponse(::Week6Assignment::PlayerInventoryResponse* value);
  ::Week6Assignment::PlayerInventoryResponse* unsafe_arena_release_playerinventoryresponse();

  private:
  const ::Week6Assignment::PlayerInventoryResponse& _internal_playerinventoryresponse() const;
  ::Week6Assignment::PlayerInventoryResponse* _internal_mutable_playerinventoryresponse();

  public:
  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:Week6Assignment.WrappedResponseMessage)
 private:
  class _Internal;
  void set_has_errorresponse();
  void set_has_playerinforesponse();
  void set_has_allplayersinforesponse();
  void set_has_playerinventoryresponse();

  inline bool has_message() const;
  inline void clear_has_message();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 4, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::Week6Assignment::ErrorResponse* errorresponse_;
      ::Week6Assignment::PlayerInfoResponse* playerinforesponse_;
      ::Week6Assignment::AllPlayersInfoResponse* allplayersinforesponse_;
      ::Week6Assignment::PlayerInventoryResponse* playerinventoryresponse_;
    } message_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_PlayerInfo_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Item

// uint32 id = 1;
inline void Item::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0u;
}
inline ::uint32_t Item::id() const {
  // @@protoc_insertion_point(field_get:Week6Assignment.Item.id)
  return _internal_id();
}
inline void Item::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Week6Assignment.Item.id)
}
inline ::uint32_t Item::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void Item::_internal_set_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string name = 2;
inline void Item::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Item::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Week6Assignment.Item.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Item::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:Week6Assignment.Item.name)
}
inline std::string* Item::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Week6Assignment.Item.name)
  return _s;
}
inline const std::string& Item::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Item::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Item::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Item::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Week6Assignment.Item.name)
  return _impl_.name_.Release();
}
inline void Item::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Week6Assignment.Item.name)
}

// uint32 quantity = 3;
inline void Item::clear_quantity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.quantity_ = 0u;
}
inline ::uint32_t Item::quantity() const {
  // @@protoc_insertion_point(field_get:Week6Assignment.Item.quantity)
  return _internal_quantity();
}
inline void Item::set_quantity(::uint32_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:Week6Assignment.Item.quantity)
}
inline ::uint32_t Item::_internal_quantity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.quantity_;
}
inline void Item::_internal_set_quantity(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.quantity_ = value;
}

// -------------------------------------------------------------------

// Inventory

// repeated .Week6Assignment.Item item = 1;
inline int Inventory::_internal_item_size() const {
  return _internal_item().size();
}
inline int Inventory::item_size() const {
  return _internal_item_size();
}
inline void Inventory::clear_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_.Clear();
}
inline ::Week6Assignment::Item* Inventory::mutable_item(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:Week6Assignment.Inventory.item)
  return _internal_mutable_item()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::Week6Assignment::Item>* Inventory::mutable_item()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:Week6Assignment.Inventory.item)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_item();
}
inline const ::Week6Assignment::Item& Inventory::item(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Week6Assignment.Inventory.item)
  return _internal_item().Get(index);
}
inline ::Week6Assignment::Item* Inventory::add_item() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::Week6Assignment::Item* _add = _internal_mutable_item()->Add();
  // @@protoc_insertion_point(field_add:Week6Assignment.Inventory.item)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::Week6Assignment::Item>& Inventory::item() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:Week6Assignment.Inventory.item)
  return _internal_item();
}
inline const ::google::protobuf::RepeatedPtrField<::Week6Assignment::Item>&
Inventory::_internal_item() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_;
}
inline ::google::protobuf::RepeatedPtrField<::Week6Assignment::Item>*
Inventory::_internal_mutable_item() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.item_;
}

// -------------------------------------------------------------------

// PlayerInfo

// uint32 id = 1;
inline void PlayerInfo::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0u;
}
inline ::uint32_t PlayerInfo::id() const {
  // @@protoc_insertion_point(field_get:Week6Assignment.PlayerInfo.id)
  return _internal_id();
}
inline void PlayerInfo::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Week6Assignment.PlayerInfo.id)
}
inline ::uint32_t PlayerInfo::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void PlayerInfo::_internal_set_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// string displayName = 2;
inline void PlayerInfo::clear_displayname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.displayname_.ClearToEmpty();
}
inline const std::string& PlayerInfo::displayname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Week6Assignment.PlayerInfo.displayName)
  return _internal_displayname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlayerInfo::set_displayname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.displayname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:Week6Assignment.PlayerInfo.displayName)
}
inline std::string* PlayerInfo::mutable_displayname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_displayname();
  // @@protoc_insertion_point(field_mutable:Week6Assignment.PlayerInfo.displayName)
  return _s;
}
inline const std::string& PlayerInfo::_internal_displayname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.displayname_.Get();
}
inline void PlayerInfo::_internal_set_displayname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.displayname_.Set(value, GetArena());
}
inline std::string* PlayerInfo::_internal_mutable_displayname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.displayname_.Mutable( GetArena());
}
inline std::string* PlayerInfo::release_displayname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Week6Assignment.PlayerInfo.displayName)
  return _impl_.displayname_.Release();
}
inline void PlayerInfo::set_allocated_displayname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.displayname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.displayname_.IsDefault()) {
          _impl_.displayname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Week6Assignment.PlayerInfo.displayName)
}

// uint32 level = 3;
inline void PlayerInfo::clear_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_ = 0u;
}
inline ::uint32_t PlayerInfo::level() const {
  // @@protoc_insertion_point(field_get:Week6Assignment.PlayerInfo.level)
  return _internal_level();
}
inline void PlayerInfo::set_level(::uint32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:Week6Assignment.PlayerInfo.level)
}
inline ::uint32_t PlayerInfo::_internal_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.level_;
}
inline void PlayerInfo::_internal_set_level(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.level_ = value;
}

// uint32 hp = 4;
inline void PlayerInfo::clear_hp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hp_ = 0u;
}
inline ::uint32_t PlayerInfo::hp() const {
  // @@protoc_insertion_point(field_get:Week6Assignment.PlayerInfo.hp)
  return _internal_hp();
}
inline void PlayerInfo::set_hp(::uint32_t value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:Week6Assignment.PlayerInfo.hp)
}
inline ::uint32_t PlayerInfo::_internal_hp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hp_;
}
inline void PlayerInfo::_internal_set_hp(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hp_ = value;
}

// optional .Week6Assignment.Inventory inventory = 5;
inline bool PlayerInfo::has_inventory() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.inventory_ != nullptr);
  return value;
}
inline void PlayerInfo::clear_inventory() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.inventory_ != nullptr) _impl_.inventory_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Week6Assignment::Inventory& PlayerInfo::_internal_inventory() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Week6Assignment::Inventory* p = _impl_.inventory_;
  return p != nullptr ? *p : reinterpret_cast<const ::Week6Assignment::Inventory&>(::Week6Assignment::_Inventory_default_instance_);
}
inline const ::Week6Assignment::Inventory& PlayerInfo::inventory() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Week6Assignment.PlayerInfo.inventory)
  return _internal_inventory();
}
inline void PlayerInfo::unsafe_arena_set_allocated_inventory(::Week6Assignment::Inventory* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.inventory_);
  }
  _impl_.inventory_ = reinterpret_cast<::Week6Assignment::Inventory*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Week6Assignment.PlayerInfo.inventory)
}
inline ::Week6Assignment::Inventory* PlayerInfo::release_inventory() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Week6Assignment::Inventory* released = _impl_.inventory_;
  _impl_.inventory_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Week6Assignment::Inventory* PlayerInfo::unsafe_arena_release_inventory() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Week6Assignment.PlayerInfo.inventory)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Week6Assignment::Inventory* temp = _impl_.inventory_;
  _impl_.inventory_ = nullptr;
  return temp;
}
inline ::Week6Assignment::Inventory* PlayerInfo::_internal_mutable_inventory() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.inventory_ == nullptr) {
    auto* p = CreateMaybeMessage<::Week6Assignment::Inventory>(GetArena());
    _impl_.inventory_ = reinterpret_cast<::Week6Assignment::Inventory*>(p);
  }
  return _impl_.inventory_;
}
inline ::Week6Assignment::Inventory* PlayerInfo::mutable_inventory() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Week6Assignment::Inventory* _msg = _internal_mutable_inventory();
  // @@protoc_insertion_point(field_mutable:Week6Assignment.PlayerInfo.inventory)
  return _msg;
}
inline void PlayerInfo::set_allocated_inventory(::Week6Assignment::Inventory* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::Week6Assignment::Inventory*>(_impl_.inventory_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::Week6Assignment::Inventory*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.inventory_ = reinterpret_cast<::Week6Assignment::Inventory*>(value);
  // @@protoc_insertion_point(field_set_allocated:Week6Assignment.PlayerInfo.inventory)
}

// optional bool isBanned = 6;
inline bool PlayerInfo::has_isbanned() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PlayerInfo::clear_isbanned() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.isbanned_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool PlayerInfo::isbanned() const {
  // @@protoc_insertion_point(field_get:Week6Assignment.PlayerInfo.isBanned)
  return _internal_isbanned();
}
inline void PlayerInfo::set_isbanned(bool value) {
  _internal_set_isbanned(value);
  // @@protoc_insertion_point(field_set:Week6Assignment.PlayerInfo.isBanned)
}
inline bool PlayerInfo::_internal_isbanned() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.isbanned_;
}
inline void PlayerInfo::_internal_set_isbanned(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.isbanned_ = value;
}

// -------------------------------------------------------------------

// ErrorResponse

// string message = 1;
inline void ErrorResponse::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ErrorResponse::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Week6Assignment.ErrorResponse.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ErrorResponse::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:Week6Assignment.ErrorResponse.message)
}
inline std::string* ErrorResponse::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:Week6Assignment.ErrorResponse.message)
  return _s;
}
inline const std::string& ErrorResponse::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void ErrorResponse::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* ErrorResponse::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* ErrorResponse::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Week6Assignment.ErrorResponse.message)
  return _impl_.message_.Release();
}
inline void ErrorResponse::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Week6Assignment.ErrorResponse.message)
}

// -------------------------------------------------------------------

// PlayerInfoResponse

// .Week6Assignment.PlayerInfo player = 1;
inline bool PlayerInfoResponse::has_player() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.player_ != nullptr);
  return value;
}
inline void PlayerInfoResponse::clear_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.player_ != nullptr) _impl_.player_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Week6Assignment::PlayerInfo& PlayerInfoResponse::_internal_player() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Week6Assignment::PlayerInfo* p = _impl_.player_;
  return p != nullptr ? *p : reinterpret_cast<const ::Week6Assignment::PlayerInfo&>(::Week6Assignment::_PlayerInfo_default_instance_);
}
inline const ::Week6Assignment::PlayerInfo& PlayerInfoResponse::player() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Week6Assignment.PlayerInfoResponse.player)
  return _internal_player();
}
inline void PlayerInfoResponse::unsafe_arena_set_allocated_player(::Week6Assignment::PlayerInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.player_);
  }
  _impl_.player_ = reinterpret_cast<::Week6Assignment::PlayerInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Week6Assignment.PlayerInfoResponse.player)
}
inline ::Week6Assignment::PlayerInfo* PlayerInfoResponse::release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Week6Assignment::PlayerInfo* released = _impl_.player_;
  _impl_.player_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Week6Assignment::PlayerInfo* PlayerInfoResponse::unsafe_arena_release_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Week6Assignment.PlayerInfoResponse.player)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Week6Assignment::PlayerInfo* temp = _impl_.player_;
  _impl_.player_ = nullptr;
  return temp;
}
inline ::Week6Assignment::PlayerInfo* PlayerInfoResponse::_internal_mutable_player() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.player_ == nullptr) {
    auto* p = CreateMaybeMessage<::Week6Assignment::PlayerInfo>(GetArena());
    _impl_.player_ = reinterpret_cast<::Week6Assignment::PlayerInfo*>(p);
  }
  return _impl_.player_;
}
inline ::Week6Assignment::PlayerInfo* PlayerInfoResponse::mutable_player() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Week6Assignment::PlayerInfo* _msg = _internal_mutable_player();
  // @@protoc_insertion_point(field_mutable:Week6Assignment.PlayerInfoResponse.player)
  return _msg;
}
inline void PlayerInfoResponse::set_allocated_player(::Week6Assignment::PlayerInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::Week6Assignment::PlayerInfo*>(_impl_.player_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::Week6Assignment::PlayerInfo*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.player_ = reinterpret_cast<::Week6Assignment::PlayerInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:Week6Assignment.PlayerInfoResponse.player)
}

// -------------------------------------------------------------------

// PlayerInventoryResponse

// uint32 playerId = 1;
inline void PlayerInventoryResponse::clear_playerid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.playerid_ = 0u;
}
inline ::uint32_t PlayerInventoryResponse::playerid() const {
  // @@protoc_insertion_point(field_get:Week6Assignment.PlayerInventoryResponse.playerId)
  return _internal_playerid();
}
inline void PlayerInventoryResponse::set_playerid(::uint32_t value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:Week6Assignment.PlayerInventoryResponse.playerId)
}
inline ::uint32_t PlayerInventoryResponse::_internal_playerid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.playerid_;
}
inline void PlayerInventoryResponse::_internal_set_playerid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.playerid_ = value;
}

// .Week6Assignment.Inventory inventory = 2;
inline bool PlayerInventoryResponse::has_inventory() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.inventory_ != nullptr);
  return value;
}
inline void PlayerInventoryResponse::clear_inventory() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.inventory_ != nullptr) _impl_.inventory_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::Week6Assignment::Inventory& PlayerInventoryResponse::_internal_inventory() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::Week6Assignment::Inventory* p = _impl_.inventory_;
  return p != nullptr ? *p : reinterpret_cast<const ::Week6Assignment::Inventory&>(::Week6Assignment::_Inventory_default_instance_);
}
inline const ::Week6Assignment::Inventory& PlayerInventoryResponse::inventory() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Week6Assignment.PlayerInventoryResponse.inventory)
  return _internal_inventory();
}
inline void PlayerInventoryResponse::unsafe_arena_set_allocated_inventory(::Week6Assignment::Inventory* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.inventory_);
  }
  _impl_.inventory_ = reinterpret_cast<::Week6Assignment::Inventory*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Week6Assignment.PlayerInventoryResponse.inventory)
}
inline ::Week6Assignment::Inventory* PlayerInventoryResponse::release_inventory() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Week6Assignment::Inventory* released = _impl_.inventory_;
  _impl_.inventory_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::Week6Assignment::Inventory* PlayerInventoryResponse::unsafe_arena_release_inventory() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:Week6Assignment.PlayerInventoryResponse.inventory)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::Week6Assignment::Inventory* temp = _impl_.inventory_;
  _impl_.inventory_ = nullptr;
  return temp;
}
inline ::Week6Assignment::Inventory* PlayerInventoryResponse::_internal_mutable_inventory() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.inventory_ == nullptr) {
    auto* p = CreateMaybeMessage<::Week6Assignment::Inventory>(GetArena());
    _impl_.inventory_ = reinterpret_cast<::Week6Assignment::Inventory*>(p);
  }
  return _impl_.inventory_;
}
inline ::Week6Assignment::Inventory* PlayerInventoryResponse::mutable_inventory() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Week6Assignment::Inventory* _msg = _internal_mutable_inventory();
  // @@protoc_insertion_point(field_mutable:Week6Assignment.PlayerInventoryResponse.inventory)
  return _msg;
}
inline void PlayerInventoryResponse::set_allocated_inventory(::Week6Assignment::Inventory* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::Week6Assignment::Inventory*>(_impl_.inventory_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::Week6Assignment::Inventory*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.inventory_ = reinterpret_cast<::Week6Assignment::Inventory*>(value);
  // @@protoc_insertion_point(field_set_allocated:Week6Assignment.PlayerInventoryResponse.inventory)
}

// -------------------------------------------------------------------

// AllPlayersInfoResponse

// repeated .Week6Assignment.PlayerInfo players = 1;
inline int AllPlayersInfoResponse::_internal_players_size() const {
  return _internal_players().size();
}
inline int AllPlayersInfoResponse::players_size() const {
  return _internal_players_size();
}
inline void AllPlayersInfoResponse::clear_players() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.players_.Clear();
}
inline ::Week6Assignment::PlayerInfo* AllPlayersInfoResponse::mutable_players(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:Week6Assignment.AllPlayersInfoResponse.players)
  return _internal_mutable_players()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::Week6Assignment::PlayerInfo>* AllPlayersInfoResponse::mutable_players()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:Week6Assignment.AllPlayersInfoResponse.players)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_players();
}
inline const ::Week6Assignment::PlayerInfo& AllPlayersInfoResponse::players(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Week6Assignment.AllPlayersInfoResponse.players)
  return _internal_players().Get(index);
}
inline ::Week6Assignment::PlayerInfo* AllPlayersInfoResponse::add_players() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::Week6Assignment::PlayerInfo* _add = _internal_mutable_players()->Add();
  // @@protoc_insertion_point(field_add:Week6Assignment.AllPlayersInfoResponse.players)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::Week6Assignment::PlayerInfo>& AllPlayersInfoResponse::players() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:Week6Assignment.AllPlayersInfoResponse.players)
  return _internal_players();
}
inline const ::google::protobuf::RepeatedPtrField<::Week6Assignment::PlayerInfo>&
AllPlayersInfoResponse::_internal_players() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.players_;
}
inline ::google::protobuf::RepeatedPtrField<::Week6Assignment::PlayerInfo>*
AllPlayersInfoResponse::_internal_mutable_players() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.players_;
}

// -------------------------------------------------------------------

// PlayerInfoRequest

// uint32 id = 1;
inline void PlayerInfoRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0u;
}
inline ::uint32_t PlayerInfoRequest::id() const {
  // @@protoc_insertion_point(field_get:Week6Assignment.PlayerInfoRequest.id)
  return _internal_id();
}
inline void PlayerInfoRequest::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Week6Assignment.PlayerInfoRequest.id)
}
inline ::uint32_t PlayerInfoRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void PlayerInfoRequest::_internal_set_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// PlayerInventoryRequest

// uint32 id = 1;
inline void PlayerInventoryRequest::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0u;
}
inline ::uint32_t PlayerInventoryRequest::id() const {
  // @@protoc_insertion_point(field_get:Week6Assignment.PlayerInventoryRequest.id)
  return _internal_id();
}
inline void PlayerInventoryRequest::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Week6Assignment.PlayerInventoryRequest.id)
}
inline ::uint32_t PlayerInventoryRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void PlayerInventoryRequest::_internal_set_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// AllPlayersInfoRequest

// -------------------------------------------------------------------

// WrappedRequestMessage

// .Week6Assignment.PlayerInfoRequest playerInfoRequest = 1;
inline bool WrappedRequestMessage::has_playerinforequest() const {
  return message_case() == kPlayerInfoRequest;
}
inline bool WrappedRequestMessage::_internal_has_playerinforequest() const {
  return message_case() == kPlayerInfoRequest;
}
inline void WrappedRequestMessage::set_has_playerinforequest() {
  _impl_._oneof_case_[0] = kPlayerInfoRequest;
}
inline void WrappedRequestMessage::clear_playerinforequest() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_case() == kPlayerInfoRequest) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.playerinforequest_;
    }
    clear_has_message();
  }
}
inline ::Week6Assignment::PlayerInfoRequest* WrappedRequestMessage::release_playerinforequest() {
  // @@protoc_insertion_point(field_release:Week6Assignment.WrappedRequestMessage.playerInfoRequest)
  if (message_case() == kPlayerInfoRequest) {
    clear_has_message();
    auto* temp = _impl_.message_.playerinforequest_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.playerinforequest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Week6Assignment::PlayerInfoRequest& WrappedRequestMessage::_internal_playerinforequest() const {
  return message_case() == kPlayerInfoRequest ? *_impl_.message_.playerinforequest_ : reinterpret_cast<::Week6Assignment::PlayerInfoRequest&>(::Week6Assignment::_PlayerInfoRequest_default_instance_);
}
inline const ::Week6Assignment::PlayerInfoRequest& WrappedRequestMessage::playerinforequest() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Week6Assignment.WrappedRequestMessage.playerInfoRequest)
  return _internal_playerinforequest();
}
inline ::Week6Assignment::PlayerInfoRequest* WrappedRequestMessage::unsafe_arena_release_playerinforequest() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Week6Assignment.WrappedRequestMessage.playerInfoRequest)
  if (message_case() == kPlayerInfoRequest) {
    clear_has_message();
    auto* temp = _impl_.message_.playerinforequest_;
    _impl_.message_.playerinforequest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WrappedRequestMessage::unsafe_arena_set_allocated_playerinforequest(::Week6Assignment::PlayerInfoRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_playerinforequest();
    _impl_.message_.playerinforequest_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Week6Assignment.WrappedRequestMessage.playerInfoRequest)
}
inline ::Week6Assignment::PlayerInfoRequest* WrappedRequestMessage::_internal_mutable_playerinforequest() {
  if (message_case() != kPlayerInfoRequest) {
    clear_message();
    set_has_playerinforequest();
    _impl_.message_.playerinforequest_ = CreateMaybeMessage<::Week6Assignment::PlayerInfoRequest>(GetArena());
  }
  return _impl_.message_.playerinforequest_;
}
inline ::Week6Assignment::PlayerInfoRequest* WrappedRequestMessage::mutable_playerinforequest() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Week6Assignment::PlayerInfoRequest* _msg = _internal_mutable_playerinforequest();
  // @@protoc_insertion_point(field_mutable:Week6Assignment.WrappedRequestMessage.playerInfoRequest)
  return _msg;
}

// .Week6Assignment.AllPlayersInfoRequest allPlayersInfoRequest = 2;
inline bool WrappedRequestMessage::has_allplayersinforequest() const {
  return message_case() == kAllPlayersInfoRequest;
}
inline bool WrappedRequestMessage::_internal_has_allplayersinforequest() const {
  return message_case() == kAllPlayersInfoRequest;
}
inline void WrappedRequestMessage::set_has_allplayersinforequest() {
  _impl_._oneof_case_[0] = kAllPlayersInfoRequest;
}
inline void WrappedRequestMessage::clear_allplayersinforequest() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_case() == kAllPlayersInfoRequest) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.allplayersinforequest_;
    }
    clear_has_message();
  }
}
inline ::Week6Assignment::AllPlayersInfoRequest* WrappedRequestMessage::release_allplayersinforequest() {
  // @@protoc_insertion_point(field_release:Week6Assignment.WrappedRequestMessage.allPlayersInfoRequest)
  if (message_case() == kAllPlayersInfoRequest) {
    clear_has_message();
    auto* temp = _impl_.message_.allplayersinforequest_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.allplayersinforequest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Week6Assignment::AllPlayersInfoRequest& WrappedRequestMessage::_internal_allplayersinforequest() const {
  return message_case() == kAllPlayersInfoRequest ? *_impl_.message_.allplayersinforequest_ : reinterpret_cast<::Week6Assignment::AllPlayersInfoRequest&>(::Week6Assignment::_AllPlayersInfoRequest_default_instance_);
}
inline const ::Week6Assignment::AllPlayersInfoRequest& WrappedRequestMessage::allplayersinforequest() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Week6Assignment.WrappedRequestMessage.allPlayersInfoRequest)
  return _internal_allplayersinforequest();
}
inline ::Week6Assignment::AllPlayersInfoRequest* WrappedRequestMessage::unsafe_arena_release_allplayersinforequest() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Week6Assignment.WrappedRequestMessage.allPlayersInfoRequest)
  if (message_case() == kAllPlayersInfoRequest) {
    clear_has_message();
    auto* temp = _impl_.message_.allplayersinforequest_;
    _impl_.message_.allplayersinforequest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WrappedRequestMessage::unsafe_arena_set_allocated_allplayersinforequest(::Week6Assignment::AllPlayersInfoRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_allplayersinforequest();
    _impl_.message_.allplayersinforequest_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Week6Assignment.WrappedRequestMessage.allPlayersInfoRequest)
}
inline ::Week6Assignment::AllPlayersInfoRequest* WrappedRequestMessage::_internal_mutable_allplayersinforequest() {
  if (message_case() != kAllPlayersInfoRequest) {
    clear_message();
    set_has_allplayersinforequest();
    _impl_.message_.allplayersinforequest_ = CreateMaybeMessage<::Week6Assignment::AllPlayersInfoRequest>(GetArena());
  }
  return _impl_.message_.allplayersinforequest_;
}
inline ::Week6Assignment::AllPlayersInfoRequest* WrappedRequestMessage::mutable_allplayersinforequest() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Week6Assignment::AllPlayersInfoRequest* _msg = _internal_mutable_allplayersinforequest();
  // @@protoc_insertion_point(field_mutable:Week6Assignment.WrappedRequestMessage.allPlayersInfoRequest)
  return _msg;
}

// .Week6Assignment.PlayerInventoryRequest playerInventoryRequest = 3;
inline bool WrappedRequestMessage::has_playerinventoryrequest() const {
  return message_case() == kPlayerInventoryRequest;
}
inline bool WrappedRequestMessage::_internal_has_playerinventoryrequest() const {
  return message_case() == kPlayerInventoryRequest;
}
inline void WrappedRequestMessage::set_has_playerinventoryrequest() {
  _impl_._oneof_case_[0] = kPlayerInventoryRequest;
}
inline void WrappedRequestMessage::clear_playerinventoryrequest() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_case() == kPlayerInventoryRequest) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.playerinventoryrequest_;
    }
    clear_has_message();
  }
}
inline ::Week6Assignment::PlayerInventoryRequest* WrappedRequestMessage::release_playerinventoryrequest() {
  // @@protoc_insertion_point(field_release:Week6Assignment.WrappedRequestMessage.playerInventoryRequest)
  if (message_case() == kPlayerInventoryRequest) {
    clear_has_message();
    auto* temp = _impl_.message_.playerinventoryrequest_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.playerinventoryrequest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Week6Assignment::PlayerInventoryRequest& WrappedRequestMessage::_internal_playerinventoryrequest() const {
  return message_case() == kPlayerInventoryRequest ? *_impl_.message_.playerinventoryrequest_ : reinterpret_cast<::Week6Assignment::PlayerInventoryRequest&>(::Week6Assignment::_PlayerInventoryRequest_default_instance_);
}
inline const ::Week6Assignment::PlayerInventoryRequest& WrappedRequestMessage::playerinventoryrequest() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Week6Assignment.WrappedRequestMessage.playerInventoryRequest)
  return _internal_playerinventoryrequest();
}
inline ::Week6Assignment::PlayerInventoryRequest* WrappedRequestMessage::unsafe_arena_release_playerinventoryrequest() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Week6Assignment.WrappedRequestMessage.playerInventoryRequest)
  if (message_case() == kPlayerInventoryRequest) {
    clear_has_message();
    auto* temp = _impl_.message_.playerinventoryrequest_;
    _impl_.message_.playerinventoryrequest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WrappedRequestMessage::unsafe_arena_set_allocated_playerinventoryrequest(::Week6Assignment::PlayerInventoryRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_playerinventoryrequest();
    _impl_.message_.playerinventoryrequest_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Week6Assignment.WrappedRequestMessage.playerInventoryRequest)
}
inline ::Week6Assignment::PlayerInventoryRequest* WrappedRequestMessage::_internal_mutable_playerinventoryrequest() {
  if (message_case() != kPlayerInventoryRequest) {
    clear_message();
    set_has_playerinventoryrequest();
    _impl_.message_.playerinventoryrequest_ = CreateMaybeMessage<::Week6Assignment::PlayerInventoryRequest>(GetArena());
  }
  return _impl_.message_.playerinventoryrequest_;
}
inline ::Week6Assignment::PlayerInventoryRequest* WrappedRequestMessage::mutable_playerinventoryrequest() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Week6Assignment::PlayerInventoryRequest* _msg = _internal_mutable_playerinventoryrequest();
  // @@protoc_insertion_point(field_mutable:Week6Assignment.WrappedRequestMessage.playerInventoryRequest)
  return _msg;
}

inline bool WrappedRequestMessage::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void WrappedRequestMessage::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline WrappedRequestMessage::MessageCase WrappedRequestMessage::message_case() const {
  return WrappedRequestMessage::MessageCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// WrappedResponseMessage

// .Week6Assignment.ErrorResponse errorResponse = 1;
inline bool WrappedResponseMessage::has_errorresponse() const {
  return message_case() == kErrorResponse;
}
inline bool WrappedResponseMessage::_internal_has_errorresponse() const {
  return message_case() == kErrorResponse;
}
inline void WrappedResponseMessage::set_has_errorresponse() {
  _impl_._oneof_case_[0] = kErrorResponse;
}
inline void WrappedResponseMessage::clear_errorresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_case() == kErrorResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.errorresponse_;
    }
    clear_has_message();
  }
}
inline ::Week6Assignment::ErrorResponse* WrappedResponseMessage::release_errorresponse() {
  // @@protoc_insertion_point(field_release:Week6Assignment.WrappedResponseMessage.errorResponse)
  if (message_case() == kErrorResponse) {
    clear_has_message();
    auto* temp = _impl_.message_.errorresponse_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.errorresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Week6Assignment::ErrorResponse& WrappedResponseMessage::_internal_errorresponse() const {
  return message_case() == kErrorResponse ? *_impl_.message_.errorresponse_ : reinterpret_cast<::Week6Assignment::ErrorResponse&>(::Week6Assignment::_ErrorResponse_default_instance_);
}
inline const ::Week6Assignment::ErrorResponse& WrappedResponseMessage::errorresponse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Week6Assignment.WrappedResponseMessage.errorResponse)
  return _internal_errorresponse();
}
inline ::Week6Assignment::ErrorResponse* WrappedResponseMessage::unsafe_arena_release_errorresponse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Week6Assignment.WrappedResponseMessage.errorResponse)
  if (message_case() == kErrorResponse) {
    clear_has_message();
    auto* temp = _impl_.message_.errorresponse_;
    _impl_.message_.errorresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WrappedResponseMessage::unsafe_arena_set_allocated_errorresponse(::Week6Assignment::ErrorResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_errorresponse();
    _impl_.message_.errorresponse_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Week6Assignment.WrappedResponseMessage.errorResponse)
}
inline ::Week6Assignment::ErrorResponse* WrappedResponseMessage::_internal_mutable_errorresponse() {
  if (message_case() != kErrorResponse) {
    clear_message();
    set_has_errorresponse();
    _impl_.message_.errorresponse_ = CreateMaybeMessage<::Week6Assignment::ErrorResponse>(GetArena());
  }
  return _impl_.message_.errorresponse_;
}
inline ::Week6Assignment::ErrorResponse* WrappedResponseMessage::mutable_errorresponse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Week6Assignment::ErrorResponse* _msg = _internal_mutable_errorresponse();
  // @@protoc_insertion_point(field_mutable:Week6Assignment.WrappedResponseMessage.errorResponse)
  return _msg;
}

// .Week6Assignment.PlayerInfoResponse playerInfoResponse = 2;
inline bool WrappedResponseMessage::has_playerinforesponse() const {
  return message_case() == kPlayerInfoResponse;
}
inline bool WrappedResponseMessage::_internal_has_playerinforesponse() const {
  return message_case() == kPlayerInfoResponse;
}
inline void WrappedResponseMessage::set_has_playerinforesponse() {
  _impl_._oneof_case_[0] = kPlayerInfoResponse;
}
inline void WrappedResponseMessage::clear_playerinforesponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_case() == kPlayerInfoResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.playerinforesponse_;
    }
    clear_has_message();
  }
}
inline ::Week6Assignment::PlayerInfoResponse* WrappedResponseMessage::release_playerinforesponse() {
  // @@protoc_insertion_point(field_release:Week6Assignment.WrappedResponseMessage.playerInfoResponse)
  if (message_case() == kPlayerInfoResponse) {
    clear_has_message();
    auto* temp = _impl_.message_.playerinforesponse_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.playerinforesponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Week6Assignment::PlayerInfoResponse& WrappedResponseMessage::_internal_playerinforesponse() const {
  return message_case() == kPlayerInfoResponse ? *_impl_.message_.playerinforesponse_ : reinterpret_cast<::Week6Assignment::PlayerInfoResponse&>(::Week6Assignment::_PlayerInfoResponse_default_instance_);
}
inline const ::Week6Assignment::PlayerInfoResponse& WrappedResponseMessage::playerinforesponse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Week6Assignment.WrappedResponseMessage.playerInfoResponse)
  return _internal_playerinforesponse();
}
inline ::Week6Assignment::PlayerInfoResponse* WrappedResponseMessage::unsafe_arena_release_playerinforesponse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Week6Assignment.WrappedResponseMessage.playerInfoResponse)
  if (message_case() == kPlayerInfoResponse) {
    clear_has_message();
    auto* temp = _impl_.message_.playerinforesponse_;
    _impl_.message_.playerinforesponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WrappedResponseMessage::unsafe_arena_set_allocated_playerinforesponse(::Week6Assignment::PlayerInfoResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_playerinforesponse();
    _impl_.message_.playerinforesponse_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Week6Assignment.WrappedResponseMessage.playerInfoResponse)
}
inline ::Week6Assignment::PlayerInfoResponse* WrappedResponseMessage::_internal_mutable_playerinforesponse() {
  if (message_case() != kPlayerInfoResponse) {
    clear_message();
    set_has_playerinforesponse();
    _impl_.message_.playerinforesponse_ = CreateMaybeMessage<::Week6Assignment::PlayerInfoResponse>(GetArena());
  }
  return _impl_.message_.playerinforesponse_;
}
inline ::Week6Assignment::PlayerInfoResponse* WrappedResponseMessage::mutable_playerinforesponse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Week6Assignment::PlayerInfoResponse* _msg = _internal_mutable_playerinforesponse();
  // @@protoc_insertion_point(field_mutable:Week6Assignment.WrappedResponseMessage.playerInfoResponse)
  return _msg;
}

// .Week6Assignment.AllPlayersInfoResponse allPlayersInfoResponse = 3;
inline bool WrappedResponseMessage::has_allplayersinforesponse() const {
  return message_case() == kAllPlayersInfoResponse;
}
inline bool WrappedResponseMessage::_internal_has_allplayersinforesponse() const {
  return message_case() == kAllPlayersInfoResponse;
}
inline void WrappedResponseMessage::set_has_allplayersinforesponse() {
  _impl_._oneof_case_[0] = kAllPlayersInfoResponse;
}
inline void WrappedResponseMessage::clear_allplayersinforesponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_case() == kAllPlayersInfoResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.allplayersinforesponse_;
    }
    clear_has_message();
  }
}
inline ::Week6Assignment::AllPlayersInfoResponse* WrappedResponseMessage::release_allplayersinforesponse() {
  // @@protoc_insertion_point(field_release:Week6Assignment.WrappedResponseMessage.allPlayersInfoResponse)
  if (message_case() == kAllPlayersInfoResponse) {
    clear_has_message();
    auto* temp = _impl_.message_.allplayersinforesponse_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.allplayersinforesponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Week6Assignment::AllPlayersInfoResponse& WrappedResponseMessage::_internal_allplayersinforesponse() const {
  return message_case() == kAllPlayersInfoResponse ? *_impl_.message_.allplayersinforesponse_ : reinterpret_cast<::Week6Assignment::AllPlayersInfoResponse&>(::Week6Assignment::_AllPlayersInfoResponse_default_instance_);
}
inline const ::Week6Assignment::AllPlayersInfoResponse& WrappedResponseMessage::allplayersinforesponse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Week6Assignment.WrappedResponseMessage.allPlayersInfoResponse)
  return _internal_allplayersinforesponse();
}
inline ::Week6Assignment::AllPlayersInfoResponse* WrappedResponseMessage::unsafe_arena_release_allplayersinforesponse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Week6Assignment.WrappedResponseMessage.allPlayersInfoResponse)
  if (message_case() == kAllPlayersInfoResponse) {
    clear_has_message();
    auto* temp = _impl_.message_.allplayersinforesponse_;
    _impl_.message_.allplayersinforesponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WrappedResponseMessage::unsafe_arena_set_allocated_allplayersinforesponse(::Week6Assignment::AllPlayersInfoResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_allplayersinforesponse();
    _impl_.message_.allplayersinforesponse_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Week6Assignment.WrappedResponseMessage.allPlayersInfoResponse)
}
inline ::Week6Assignment::AllPlayersInfoResponse* WrappedResponseMessage::_internal_mutable_allplayersinforesponse() {
  if (message_case() != kAllPlayersInfoResponse) {
    clear_message();
    set_has_allplayersinforesponse();
    _impl_.message_.allplayersinforesponse_ = CreateMaybeMessage<::Week6Assignment::AllPlayersInfoResponse>(GetArena());
  }
  return _impl_.message_.allplayersinforesponse_;
}
inline ::Week6Assignment::AllPlayersInfoResponse* WrappedResponseMessage::mutable_allplayersinforesponse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Week6Assignment::AllPlayersInfoResponse* _msg = _internal_mutable_allplayersinforesponse();
  // @@protoc_insertion_point(field_mutable:Week6Assignment.WrappedResponseMessage.allPlayersInfoResponse)
  return _msg;
}

// .Week6Assignment.PlayerInventoryResponse playerInventoryResponse = 4;
inline bool WrappedResponseMessage::has_playerinventoryresponse() const {
  return message_case() == kPlayerInventoryResponse;
}
inline bool WrappedResponseMessage::_internal_has_playerinventoryresponse() const {
  return message_case() == kPlayerInventoryResponse;
}
inline void WrappedResponseMessage::set_has_playerinventoryresponse() {
  _impl_._oneof_case_[0] = kPlayerInventoryResponse;
}
inline void WrappedResponseMessage::clear_playerinventoryresponse() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_case() == kPlayerInventoryResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.playerinventoryresponse_;
    }
    clear_has_message();
  }
}
inline ::Week6Assignment::PlayerInventoryResponse* WrappedResponseMessage::release_playerinventoryresponse() {
  // @@protoc_insertion_point(field_release:Week6Assignment.WrappedResponseMessage.playerInventoryResponse)
  if (message_case() == kPlayerInventoryResponse) {
    clear_has_message();
    auto* temp = _impl_.message_.playerinventoryresponse_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.playerinventoryresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Week6Assignment::PlayerInventoryResponse& WrappedResponseMessage::_internal_playerinventoryresponse() const {
  return message_case() == kPlayerInventoryResponse ? *_impl_.message_.playerinventoryresponse_ : reinterpret_cast<::Week6Assignment::PlayerInventoryResponse&>(::Week6Assignment::_PlayerInventoryResponse_default_instance_);
}
inline const ::Week6Assignment::PlayerInventoryResponse& WrappedResponseMessage::playerinventoryresponse() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:Week6Assignment.WrappedResponseMessage.playerInventoryResponse)
  return _internal_playerinventoryresponse();
}
inline ::Week6Assignment::PlayerInventoryResponse* WrappedResponseMessage::unsafe_arena_release_playerinventoryresponse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Week6Assignment.WrappedResponseMessage.playerInventoryResponse)
  if (message_case() == kPlayerInventoryResponse) {
    clear_has_message();
    auto* temp = _impl_.message_.playerinventoryresponse_;
    _impl_.message_.playerinventoryresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void WrappedResponseMessage::unsafe_arena_set_allocated_playerinventoryresponse(::Week6Assignment::PlayerInventoryResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_playerinventoryresponse();
    _impl_.message_.playerinventoryresponse_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Week6Assignment.WrappedResponseMessage.playerInventoryResponse)
}
inline ::Week6Assignment::PlayerInventoryResponse* WrappedResponseMessage::_internal_mutable_playerinventoryresponse() {
  if (message_case() != kPlayerInventoryResponse) {
    clear_message();
    set_has_playerinventoryresponse();
    _impl_.message_.playerinventoryresponse_ = CreateMaybeMessage<::Week6Assignment::PlayerInventoryResponse>(GetArena());
  }
  return _impl_.message_.playerinventoryresponse_;
}
inline ::Week6Assignment::PlayerInventoryResponse* WrappedResponseMessage::mutable_playerinventoryresponse() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::Week6Assignment::PlayerInventoryResponse* _msg = _internal_mutable_playerinventoryresponse();
  // @@protoc_insertion_point(field_mutable:Week6Assignment.WrappedResponseMessage.playerInventoryResponse)
  return _msg;
}

inline bool WrappedResponseMessage::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void WrappedResponseMessage::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline WrappedResponseMessage::MessageCase WrappedResponseMessage::message_case() const {
  return WrappedResponseMessage::MessageCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace Week6Assignment


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_PlayerInfo_2eproto_2epb_2eh
